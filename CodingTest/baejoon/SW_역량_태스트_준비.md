# [SW 역량 테스트 준비](https://www.acmicpc.net/workbook/codeplus)
> By solbot

## [SW 역량 테스트 준비 - 기초 [수학]](https://www.acmicpc.net/workbook/view/3935)
### [나머지](https://www.acmicpc.net/problem/10430)
문제에서 주어진 식을 그대로 계산하여 출력하면 되는 문제이다.

### [최대공약수와 최소공배수](https://www.acmicpc.net/problem/2609)
#### 완전 탐색
두 수 a, b의 최대공약수는 a, b를 나눌 수 있는 가장 큰 수를 의미한다. 따라서 min(a, b) 루프를 돌면서 두 수를 모두 나눌 수 있는 값을 계속 갱신한다면 쉽게 찾을 수 있다. 여기서 시간복잡도는 O(min(a,b))이다.

최소공배수는 두 수 a, b를 미리 구한 최대공약수로 나눈 값을 곱한 값이 된다. 여기서 시간복잡도는 O(1)이므로 최대공약수와 최대공배수를 모두 구하는 시간복잡도는 O(min(a,b))가 된다.

이 방법에서 조금 더 빠르게 해결하기 위해서는 나눌 수 있는 수를 찾는 루프를 큰 수부터 작은 수 순서로 돌리면서 두 수를 나눌 수 있는 수를 찾는 순간 반복문을 나가면 된다.

#### 유클리드 호제법
> 유클리드 호제법?
>
> f(a, b) = gcd(a, b)라 합시다. 이 때 a mod b = 0 이라면, f(a, b) = b임이 자명함을 알 수 있습니다. 이 때 a mod b이 0이 아닌 경우, f(a, b) = f(b, a mod b)가 성립하는 것을 말합니다.

유클리드 호제법으로 해결한 시간복잡도는 O(log(min(a, b)))이다. mod한 과정이 반으로 나눠지는 정도로 생각할 수 있다고 한다.

#### 참고
- <https://opentutorials.org/course/1685/9533>


### [최소공배수](https://www.acmicpc.net/problem/1934)
위에서 풀었던 방법 그대로 적용하면 된다.


### [GCD 합](https://www.acmicpc.net/problem/9613)
GCD 구하는 방법은 위 유클리드 호제법을 사용할 수 있다. 그러면 시간복잡도는 다음과 같다.
- T: 테스트 개수 (최대 100)
- N: 해당 테스트에서 숫자 개수 (최대 100)
- num: 해당 숫자 (최대 1,000,000)

=> O(T * N * (N - 1) * log(num))
=> 최대 시간복잡도는 100 * 100 * 99 * log1000000 이므로, 1초안에 충분히 동작이 가능하다.

여기서 주의할 점은 합의 최대 크기인데, 할 수 있는 최대 합은 100 * 100 * 99 * 1,000,000이다. 이는 990,000,000,000이므로 int 값 제한을 훨씬 넘는다. 따라서 longlong을 사용해야 한다.

### [소수 찾기](https://www.acmicpc.net/problem/1978)
#### 완전탐색
최대 입력 크기가 100개, 최대 숫자의 크기가 1,000이므로 단순한 완전탐색으로 풀 수 있다. 소수는 2보다 큰 숫자일 때 2부터 자기 자신보다 1 작은 숫자일 때까지 나눠지지 않는다면 소수이다.

시간복잡도는 입력 크기가 N, 숫자의 크기가 M일 때, O(NM)이다.

#### 에라토스테네스의 체
에라토스테네스의 체는 이름 그대로 체로 거르는 작업을 말한다. 소수인 2부터 시작해서 2의 배수는 모두 소수가 될 수 없으므로 거른다. 이를 주어진 숫자만큼 반복한다. 이러한 거르는 숫자 크기는 주어진 숫자의 제곱근까지만 하면 된다. 예를 들어 주어진 숫자가 120이라면 `11^2 < 120 < 12^2` 이므로 최대 거르는 수는 11까지만 검사하면 된다. 이보다 큰 수는 이미 이전 수에서 걸러지기 때문이다.

```cpp
void Eratos(int n)
{
    /*  만일 n이 1보다 작거나 같으면 함수 종료 */
    if (n <= 1) return;

    /*	2부터 n까지 n-1개를 저장할 수 있는 배열 할당
		배열 참조 번호와 소수와 일치하도록 배열의 크기는
		n+1 길이만큼 할당(인덱스 번호 0과 1은 사용하지 않음)	*/
	bool* PrimeArray = new bool[n + 1];

	/*  배열초기화: 처음엔 모두 소수로 보고 true값을 줌	*/
	for (int i = 2; i <= n; i++)
	    PrimeArray[i] = true;

	/*	에라토스테네스의 체에 맞게 소수를 구함
		만일, PrimeArray[i]가 true이면 i 이후의 i 배수는 약수로 i를
		가지고 있는 것이 되므로 i 이후의 i 배수에 대해 false값을 준다.
		PrimeArray[i]가 false이면 i는 이미 소수가 아니므로 i의 배수 역시
		소수가 아니게 된다. 그러므로 검사할 필요도 없다.
또한 i*k (k < i) 까지는 이미 검사되었으므로 j시작 값은 i*2 에서 i*i로 개선할 수 있다.
	*/
	for (int i = 2; i * i <= n; i++)
	{
		if (PrimeArray[i])
			for (int j = i * i; j <= n; j += i)
			    PrimeArray[j] = false;
	}

	// 이후의 작업 ...
}
```

시간복잡도는 O(NloglogN) 이라고 한다. (https://www.acmicpc.net/board/view/1663)

참고: <https://ko.wikipedia.org/wiki/%EC%97%90%EB%9D%BC%ED%86%A0%EC%8A%A4%ED%85%8C%EB%84%A4%EC%8A%A4%EC%9D%98_%EC%B2%B4>

위 에라토스테네스의 체를 이용하면 시간복잡도는 O(N + MloglogM)이 된다.


### [골드바흐의 추측](https://www.acmicpc.net/problem/6588)
미리 소수를 찾기 위해 에라토스테네스의 체를 사용하고, 테스트케이스마다 두 숫자를 찾을 때 두 수의 차이가 가장 큰 경우를 찾아야하므로 하나의 반복문에서 양 끝을 검사하도록 해야한다.


## [SW 역량 테스트 준비 - 기초 [브루트 포스]](https://www.acmicpc.net/workbook/view/3936)

### [일곱 난쟁이](https://www.acmicpc.net/problem/2309)
총 9명의 난쟁이 중 7명이 뽑는 모든 경우의 수를 구하면 된다. 이는 총 36가지의 경우의 수가 나오며, 해당 경우의 수 마다 7명의 난쟁이의 총 키의 합이 100이 되는 것을 계산해야 하므로 36 * 7로 완전탐색으로 충분히 계산가능하다.

여기서 문제를 구현하고 런타임에러가 계속 발생했는데, 재귀함수의 반환값을 설정안해주었다. 이는 Java에서는 반환값이 void가 아닌 경우에서 return 문이 모든 경우에 있어야 컴파일이 되는데, C++은 이러한 검사를 하지 않아 찾는데 조금 오래 걸렸다.

### [날짜 계산](https://www.acmicpc.net/problem/1476)
지구, 태양, 달의 최대값은 각각 15, 28, 19이다. 여기서 가장 빠른 년도를 계산하는 것이기 때문에 위로 표현할 수 있는 년도 수는 최대 15 * 28 * 19 = 7980 이다. 따라서 여유롭게 완전탐색이 가능하다.

### [테트로미노](https://www.acmicpc.net/problem/14500)
가능한 테트로미노의 개수를 구하고 정확히 좌표에 표현해야 한다. 가능한 테트로미노 종류는 19가지이므로 모든 경우의 테스트케이스를 만들어서 정확한지 판단해보는 것이 중요하다고 생각한다.

### [1, 2, 3 더하기](https://www.acmicpc.net/problem/9095)
1, 2, 3을 더하여 만드는 숫자의 최대 크기는 10이다. 그리고 순서에 상관이 없으므로 순열로 구해야 한다. 이를 재귀함수로 구현하고, 재귀함수의 시간복잡도를 어림잡으면 O(분기^깊이)이다. 따라서 최대 O(3^10)으로 볼 수 있는데, 이는 약 6만이며, 사실 이보다 훨씬 적은 양을 계산하므로 충분히 완전탐색이 가능하다.

### [다음 순열](https://www.acmicpc.net/problem/10972)
다음 순열을 구하는 방법은 C++에서 `next_permutation()` 으로 구현되어 있다. 이를 사용하면 된다. 하지만 이를 구현하려면 다음을 참고하자.

<https://rimkongs.tistory.com/m/212?category=813345>

위에 따르면 `next_permutation`은 시간복잡도 O(N)으로 구현가능하다.